function paramMap_GUI()
% paramMap_GUI - Interactive viewer for automated QVT+ outputs.
%
% This tool lets you inspect the results generated by paramMap_auto.m.
% It loads the processed QVT data, reconstructed eICAB correspondence, and
% automatically selected LOCs, then launches a lightweight GUI to explore
% the vasculature, isolate vessels, and visualize LOC positions.
%
% Usage:
%   >> paramMap_GUI
%
% The script will prompt you to select the output directory created by
% paramMap_auto (the folder containing qvtData_ISOfix_*.mat, SummaryParamTool.xls,
% multilabel_QVTseg.nii, etc.).

    outputDir = uigetdir(pwd, 'Select a QVT+ output directory');
    if isequal(outputDir, 0)
        disp('paramMap_GUI: No folder selected. Exiting.');
        return;
    end

    matInfo = dir(fullfile(outputDir, 'qvtData_ISOfix_*.mat'));
    if isempty(matInfo)
        error('paramMap_GUI:MissingData', ...
              'No qvtData_ISOfix_*.mat file found in %s.', outputDir);
    end

    % In case there are multiple processed files, pick the most recent
    [~, newestIdx] = max([matInfo.datenum]);
    matFile = fullfile(outputDir, matInfo(newestIdx).name);

    dataVars = load(matFile, 'data_struct', 'Vel_Time_Res');
    data_struct = dataVars.data_struct;
    Vel_Time_Res = dataVars.Vel_Time_Res;

    % Rebuild correspondence dictionary and LOCs from outputs on disk
    try
        [correspondenceDict, multiQVT] = generateCorrespondenceDict(outputDir, data_struct);
    catch ME
        error('paramMap_GUI:LabelFilesMissing', ...
              'Unable to rebuild correspondence dictionary: %s', ME.message);
    end

    [correspondenceDict, LOCs] = generateLOCs(data_struct, correspondenceDict, multiQVT);

    % Filter LOCs that do not have the expected [segment, idx] structure
    locKeys = fieldnames(LOCs);
    validLocMask = false(size(locKeys));
    for iKey = 1:numel(locKeys)
        entry = LOCs.(locKeys{iKey});
        validLocMask(iKey) = isnumeric(entry) && isvector(entry) && numel(entry) == 2;
    end
    locKeys = locKeys(validLocMask);

    if isempty(locKeys)
        warning('paramMap_GUI:NoLOCs', 'No LOC entries detected.');
    end

    locInfo = computeLocInfo(locKeys, LOCs, data_struct);

    vesselNames = buildDisplayNames(locKeys);
    paramOptions = createParamOptions(data_struct);
    cmapList = {'parula','turbo','jet','hot','cool','summer','autumn','winter','gray','bone'};

    app.figure = figure('Name', 'QVT+ Viewer', ...
                        'NumberTitle', 'off', ...
                        'Color', [0 0 0], ...
                        'Units', 'normalized', ...
                        'Position', [0.08 0.08 0.84 0.82]);
    movegui(app.figure, 'center');

    app.axes = axes('Parent', app.figure, ...
                    'Position', [0.05 0.32 0.6 0.63], ...
                    'Color', 'k');
    hold(app.axes, 'on');
    axis(app.axes, 'equal');
    axis(app.axes, 'off');
    view(app.axes, 3);
    % rotate3d(app.figure, 'on');

    % Try to load multilabel volume for colored isosurfaces
    multilabelPath = fullfile(outputDir, 'multilabel_QVTseg.nii');
    if exist(multilabelPath, 'file')
        try
            V = spm_vol(multilabelPath);
            multiQVTvol = spm_read_vols(V);
        catch
            multiQVTvol = [];
        end
    else
        multiQVTvol = [];
    end

    [surfacePatches, scatterAll, scatterSel] = plotCenterlines(app.axes, data_struct, correspondenceDict, multiQVTvol);
    locPlots = plotLocMarkers(app.axes, locInfo);
    cursorMarker = scatter3(app.axes, NaN, NaN, NaN, ...
                            160, [0 1 0], 'filled', ...
                            'MarkerEdgeColor', 'k', ...
                            'Visible', 'off', ...
                            'HitTest', 'off', ...
                            'PickableParts', 'none');

    colormap(app.axes, parula);

    % Compact UI layout - Group 1: Vessel and Parameter selection
    uicontrol('Style', 'text', ...
              'Parent', app.figure, ...
              'Units', 'normalized', ...
              'Position', [0.66 0.94 0.15 0.022], ...
              'String', 'Vessel', ...
              'BackgroundColor', [0.94 0.94 0.94], ...
              'FontSize', 8, ...
              'HorizontalAlignment', 'left');
    dropdownList = [{'All Vessels'}, vesselNames(:)'];
    dropdown = uicontrol('Style', 'popupmenu', ...
                         'Parent', app.figure, ...
                         'Units', 'normalized', ...
                         'Position', [0.66 0.91 0.15 0.028], ...
                         'String', dropdownList, ...
                         'BackgroundColor', [1 1 1], ...
                         'FontSize', 8);

    uicontrol('Style', 'text', ...
              'Parent', app.figure, ...
              'Units', 'normalized', ...
              'Position', [0.82 0.94 0.14 0.022], ...
              'String', 'Parameter', ...
              'BackgroundColor', [0.94 0.94 0.94], ...
              'FontSize', 8, ...
              'HorizontalAlignment', 'left');
    paramDropdown = uicontrol('Style', 'popupmenu', ...
                              'Parent', app.figure, ...
                              'Units', 'normalized', ...
                              'Position', [0.82 0.91 0.14 0.028], ...
                              'String', {paramOptions.label}, ...
                              'BackgroundColor', [1 1 1], ...
                              'FontSize', 8);
    paramDropdown.Value = 1;

    % Group 2: Colormap and Colorbar limits (compact)
    uicontrol('Style', 'text', ...
              'Parent', app.figure, ...
              'Units', 'normalized', ...
              'Position', [0.66 0.87 0.08 0.022], ...
              'String', 'Colormap', ...
              'BackgroundColor', [0.94 0.94 0.94], ...
              'FontSize', 8, ...
              'HorizontalAlignment', 'left');
    cmapDropdown = uicontrol('Style', 'popupmenu', ...
                             'Parent', app.figure, ...
                             'Units', 'normalized', ...
                             'Position', [0.66 0.84 0.08 0.028], ...
                             'String', cmapList, ...
                             'BackgroundColor', [1 1 1], ...
                             'FontSize', 8);
    cmapDropdown.Value = 1;

    uicontrol('Style', 'text', ...
              'Parent', app.figure, ...
              'Units', 'normalized', ...
              'Position', [0.75 0.87 0.05 0.022], ...
              'String', 'Min', ...
              'BackgroundColor', [0.94 0.94 0.94], ...
              'FontSize', 8, ...
              'HorizontalAlignment', 'left');
    cbMinEdit = uicontrol('Style', 'edit', ...
                          'Parent', app.figure, ...
                          'Units', 'normalized', ...
                          'Position', [0.75 0.84 0.05 0.028], ...
                          'BackgroundColor', [1 1 1], ...
                          'FontSize', 8);

    uicontrol('Style', 'text', ...
              'Parent', app.figure, ...
              'Units', 'normalized', ...
              'Position', [0.81 0.87 0.05 0.022], ...
              'String', 'Max', ...
              'BackgroundColor', [0.94 0.94 0.94], ...
              'FontSize', 8, ...
              'HorizontalAlignment', 'left');
    cbMaxEdit = uicontrol('Style', 'edit', ...
                          'Parent', app.figure, ...
                          'Units', 'normalized', ...
                          'Position', [0.81 0.84 0.05 0.028], ...
                          'BackgroundColor', [1 1 1], ...
                          'FontSize', 8);

    % Group 3: Isosurface transparency control
    uicontrol('Style', 'text', ...
              'Parent', app.figure, ...
              'Units', 'normalized', ...
              'Position', [0.87 0.87 0.09 0.022], ...
              'String', 'Mask Alpha', ...
              'BackgroundColor', [0.94 0.94 0.94], ...
              'FontSize', 8, ...
              'HorizontalAlignment', 'left');
    alphaSlider = uicontrol('Style', 'slider', ...
                            'Parent', app.figure, ...
                            'Units', 'normalized', ...
                            'Position', [0.87 0.84 0.09 0.028], ...
                            'Min', 0, ...
                            'Max', 1, ...
                            'Value', 0.3, ...
                            'SliderStep', [0.05 0.1]);

    % Group 4: Action buttons (compact)
    focusButton = uicontrol('Style', 'pushbutton', ...
                            'Parent', app.figure, ...
                            'Units', 'normalized', ...
                            'Position', [0.66 0.80 0.10 0.028], ...
                            'String', 'Focus LOC', ...
                            'FontSize', 8);

    resetButton = uicontrol('Style', 'pushbutton', ...
                            'Parent', app.figure, ...
                            'Units', 'normalized', ...
                            'Position', [0.77 0.80 0.10 0.028], ...
                            'String', 'Reset', ...
                            'FontSize', 8, ...
                            'Callback', @(~,~) resetView(app.figure));

    infoBox = uicontrol('Style', 'text', ...
                        'Parent', app.figure, ...
                        'Units', 'normalized', ...
                        'Position', [0.68 0.05 0.27 0.18], ...
                        'String', '', ...
                        'HorizontalAlignment', 'left', ...
                        'BackgroundColor', [0.2 0.2 0.2], ...
                        'ForegroundColor', [1 1 1], ...
                        'FontSize', 10);

    app.axesMAG = axes('Parent', app.figure, ...
                       'Position', [0.66 0.50 0.14 0.15], ...
                       'Color', 'k');
    app.axesCD = axes('Parent', app.figure, ...
                      'Position', [0.815 0.50 0.14 0.15], ...
                      'Color', 'k');
    app.axesVelTA = axes('Parent', app.figure, ...
                         'Position', [0.66 0.31 0.14 0.15], ...
                         'Color', 'k');
    app.axesVelTR = axes('Parent', app.figure, ...
                         'Position', [0.815 0.31 0.14 0.15], ...
                         'Color', 'k');
    app.axesWave = axes('Parent', app.figure, ...
                        'Position', [0.05 0.05 0.6 0.2], ...
                        'Color', [0.1 0.1 0.1]);

    setupCrossAxes(app.axesMAG, 'MAG');
    setupCrossAxes(app.axesCD, 'CD');
    setupCrossAxes(app.axesVelTA, 'Velocity (TA)');
    setupCrossAxes(app.axesVelTR, 'Velocity (TR)');
    prepareWaveformAxes(app.axesWave);

    try
        camlight(app.axes, 'headlight');
    catch ME
        warning('paramMap_GUI:CamlightInit','camlight failed: %s', ME.message);
    end
    lighting(app.axes, 'gouraud');

    cb = colorbar(app.axes);
    cb.Color = [1 1 1];
    cb.Label.Color = [1 1 1];

    appData.branchList = data_struct.branchList;
    appData.area_val = data_struct.area_val;
    appData.diam_val = data_struct.diam_val;
    appData.flowPerHeartCycle_val = data_struct.flowPerHeartCycle_val;
    appData.maxVel_val = data_struct.maxVel_val;
    appData.velMean_val = data_struct.velMean_val;
    appData.StdvFromMean = data_struct.StdvFromMean;
    appData.PI_val = data_struct.PI_val;
    appData.RI_val = data_struct.RI_val;
    appData.locInfo = locInfo;
    appData.correspondenceDict = correspondenceDict;
    appData.locPlots = locPlots;
    appData.scatterAll = scatterAll;
    appData.scatterSel = scatterSel;
    appData.cursorMarker = cursorMarker;
    appData.infoBox = infoBox;
    appData.axes = app.axes;
    appData.axesMAG = app.axesMAG;
    appData.axesCD = app.axesCD;
    appData.axesVelTA = app.axesVelTA;
    appData.axesVelTR = app.axesVelTR;
    appData.axesWave = app.axesWave;
    appData.selection = struct('key', '', 'locIndex', [], 'pointRow', [], 'selIndices', []);
    appData.paramOptions = paramOptions;
    appData.surfacePatches = surfacePatches;
    appData.alphaSlider = alphaSlider;
    appData.colormapList = cmapList;
    appData.paramDropdown = paramDropdown;
    appData.cmapDropdown = cmapDropdown;
    appData.cbMinEdit = cbMinEdit;
    appData.cbMaxEdit = cbMaxEdit;
    appData.colorbar = cb;
    appData.dropdown = dropdown;
    appData.locKeys = locKeys;
    appData.vesselNames = vesselNames;
    appData.flowPulsatile = data_struct.flowPulsatile_val;
    appData.nframes = data_struct.nframes;
    appData.timeres = data_struct.timeres;
    appData.segmentFull = data_struct.segmentFull;
    appData.MAGcrossection = data_struct.MAGcrossection;
    appData.timeMIPcrossection = data_struct.timeMIPcrossection;
    appData.vTimeFrameave = data_struct.vTimeFrameave;
    appData.VplanesAllx = Vel_Time_Res.VplanesAllx;
    appData.VplanesAlly = Vel_Time_Res.VplanesAlly;
    appData.VplanesAllz = Vel_Time_Res.VplanesAllz;
    appData.imdim = sqrt(size(data_struct.segmentFull, 2));
    appData.data_struct = data_struct;
    appData.currentParamIndex = 1;

    guidata(app.figure, appData);

    dropdown.Callback = @(src, ~) updateSelection(app.figure, src.Value, vesselNames, locKeys);
    paramDropdown.Callback = @(src, ~) changeParameter(app.figure, src.Value);
    cmapDropdown.Callback = @(src, ~) changeColormap(app.figure, src.Value);
    cbMinEdit.Callback = @(src, ~) updateColorLimits(app.figure, 'min', str2double(src.String));
    cbMaxEdit.Callback = @(src, ~) updateColorLimits(app.figure, 'max', str2double(src.String));
    alphaSlider.Callback = @(src, ~) updateIsosurfaceAlpha(app.figure, src.Value);
    focusButton.Callback = @(~,~) focusOnSelectedLOC(app.figure);
    resetButton.Callback = @(~,~) resetView(app.figure);

    scatterAll.ButtonDownFcn = @(src, evt) onScatterClick(app.figure, src, evt);
    scatterSel.ButtonDownFcn = @(src, evt) onScatterClick(app.figure, src, evt);

    applyParameterSelection(app.figure, 1, true);
    updateSelection(app.figure, 1, vesselNames, locKeys);

    waitfor(app.figure);
end

function locInfo = computeLocInfo(locKeys, LOCs, data_struct)
    locInfo = struct('key', {}, 'segment', {}, 'clIndex', {}, ...
                     'rowIdx', {}, 'coord', {}, 'flow', {}, ...
                     'PI', {}, 'RI', {});
    branchList = data_struct.branchList;
    for i = 1:numel(locKeys)
        key = locKeys{i};
        entry = LOCs.(key);
        segID = entry(1);
        clIdx = entry(2);
        matchRows = find(branchList(:,4) == segID & branchList(:,5) == clIdx, 1);
        if isempty(matchRows)
            warning('paramMap_GUI:MissingBranchRow', ...
                    'No branchList row found for %s (segment %d, index %d).', ...
                    key, segID, clIdx);
            continue;
        end
        locInfo(end+1).key = key; 
        locInfo(end).segment = segID;
        locInfo(end).clIndex = clIdx;
        locInfo(end).rowIdx = matchRows;
        locInfo(end).coord = branchList(matchRows, 1:3);
        locInfo(end).flow = data_struct.flowPerHeartCycle_val(matchRows);
        locInfo(end).PI = data_struct.PI_val(matchRows);
        locInfo(end).RI = data_struct.RI_val(matchRows);
    end
end

function names = buildDisplayNames(keys)
    pretty = containers.Map( ...
        {'LICA','RICA','BASI','LMCA','RMCA','LACA','RACA', ...
         'LPCA','RPCA','SSSV','LTSV','RTSV','STRV','COMM'}, ...
        {'Left ICA','Right ICA','Basilar', ...
         'Left MCA','Right MCA','Left ACA','Right ACA', ...
         'Left PCA','Right PCA','Superior Sagittal Sinus', ...
         'Left Transverse Sinus','Right Transverse Sinus','Straight Sinus','Communicating'} ...
    );
    names = cell(size(keys));
    for i = 1:numel(keys)
        key = keys{i};
        if pretty.isKey(key)
            names{i} = pretty(key);
        else
            names{i} = key;
        end
    end
end

function [surfacePatches, scatterAll, scatterSel] = plotCenterlines(ax, data_struct, correspondenceDict, multiQVTvol)
    % Generate colored isosurfaces for each vessel
    surfacePatches = struct();
    
    % Define distinct colors for each vessel type
    vesselColors = containers.Map(...
        {'LICA', 'RICA', 'BASI', 'LMCA', 'RMCA', 'LACA', 'RACA', ...
         'LPCA', 'RPCA', 'SSSV', 'LTSV', 'RTSV', 'STRV', 'COMM'}, ...
        {[1 0.2 0.2], [0.2 0.2 1], [0.2 1 0.2], [1 0.6 0.2], [0.6 0.2 1], ...
         [1 0.8 0.2], [0.8 0.2 1], [0.2 1 0.8], [0.2 0.8 1], ...
         [1 0.4 0.6], [0.4 1 0.6], [0.6 0.4 1], [0.8 0.8 0.2], [0.5 0.5 0.5]});
    
    % Use multilabel volume if available, otherwise use binary segment
    if ~isempty(multiQVTvol) && ~all(multiQVTvol(:) == 0)
        segVol = permute(multiQVTvol, [2 1 3]);
        uniqueLabels = unique(segVol(segVol > 0));
        
        % Map labels to vessel names using correspondenceDict
        labelToVessel = containers.Map('KeyType', 'double', 'ValueType', 'char');
        vesselKeys = fieldnames(correspondenceDict);
        for i = 1:numel(vesselKeys)
            key = vesselKeys{i};
            segments = correspondenceDict.(key);
            for seg = segments(:)'
                % Find which label in multiQVTvol corresponds to this segment
                % We'll use the branchList to map segments to labels
                branchMask = data_struct.branchList(:,4) == seg;
                if any(branchMask)
                    coords = round(data_struct.branchList(branchMask, 1:3));
                    % After permute([2 1 3]), coordinates are [y, x, z]
                    coordsPerm = [coords(:,2), coords(:,1), coords(:,3)];
                    validCoords = coordsPerm(:,1) >= 1 & coordsPerm(:,1) <= size(segVol,1) & ...
                                  coordsPerm(:,2) >= 1 & coordsPerm(:,2) <= size(segVol,2) & ...
                                  coordsPerm(:,3) >= 1 & coordsPerm(:,3) <= size(segVol,3);
                    if any(validCoords)
                        linearIdx = sub2ind(size(segVol), coordsPerm(validCoords,1), ...
                                           coordsPerm(validCoords,2), coordsPerm(validCoords,3));
                        labels = unique(segVol(linearIdx));
                        labels = labels(labels > 0);
                        if ~isempty(labels)
                            for lbl = labels(:)'
                                if ~isKey(labelToVessel, lbl)
                                    labelToVessel(lbl) = key;
                                end
                            end
                        end
                    end
                end
            end
        end
        
        % Create isosurface for each unique label
        for lbl = uniqueLabels(:)'
            if isKey(labelToVessel, lbl)
                vesselName = labelToVessel(lbl);
                if vesselColors.isKey(vesselName)
                    color = vesselColors(vesselName);
                else
                    color = [0.7 0.7 0.7];
                end
            else
                color = [0.7 0.7 0.7];
            end
            
            try
                maskVol = (segVol == lbl);
                if any(maskVol(:))
                    fv = isosurface(maskVol, 0.5);
                    if ~isempty(fv.vertices)
                        patchHandle = patch(ax, fv, ...
                            'FaceColor', color, ...
                            'EdgeColor', 'none', ...
                            'FaceAlpha', 0.3, ...
                            'HitTest', 'off', ...
                            'PickableParts', 'none');
                        % Store by label number to handle multiple labels per vessel
                        surfacePatches.(sprintf('Label_%d', lbl)) = patchHandle;
                    end
                end
            catch ME
                warning('paramMap_GUI:IsosurfaceLabelFailed', ...
                        'Could not generate isosurface for label %d: %s', lbl, ME.message);
            end
        end
    else
        % Fallback to binary segment with single gray isosurface
        segVol = permute(data_struct.segment, [2 1 3]);
        try
            fv = isosurface(segVol, 0.5);
            if ~isempty(fv.vertices)
                patchHandle = patch(ax, fv, ...
                    'FaceColor', [0.8 0.8 0.8], ...
                    'EdgeColor', 'none', ...
                    'FaceAlpha', 0.3, ...
                    'HitTest', 'off', ...
                    'PickableParts', 'none');
                surfacePatches.all = patchHandle;
            end
        catch ME
            warning('paramMap_GUI:IsosurfaceFailed', ...
                    'Could not generate isosurface: %s', ME.message);
        end
    end

    branchList = data_struct.branchList(:, 1:3);
    flowVals = data_struct.flowPerHeartCycle_val;

    scatterAll = scatter3(ax, branchList(:,1), branchList(:,2), branchList(:,3), ...
                          16, flowVals, 'filled', ...
                          'MarkerFaceAlpha', 0.8, ...
                          'MarkerEdgeAlpha', 0.8, ...
                          'PickableParts', 'all', ...
                          'HitTest', 'on');
    scatterSel = scatter3(ax, NaN, NaN, NaN, ...
                          40, [1 0 0], 'filled', ...
                          'MarkerEdgeColor', 'k', ...
                          'Visible', 'off', ...
                          'PickableParts', 'all', ...
                          'HitTest', 'on');
end

function locPlots = plotLocMarkers(ax, locInfo)
    if isempty(locInfo)
        locPlots.all = scatter3(ax, NaN, NaN, NaN, 80, 'w', 'filled', ...
                                'HitTest', 'off', 'PickableParts', 'none');
        locPlots.sel = scatter3(ax, NaN, NaN, NaN, 180, 'y', 'filled', ...
                                'MarkerEdgeColor', 'k', ...
                                'HitTest', 'off', 'PickableParts', 'none');
        return;
    end
    coords = vertcat(locInfo.coord);
    locPlots.all = scatter3(ax, coords(:,1), coords(:,2), coords(:,3), ...
                            90, 'w', 'filled', ...
                            'MarkerEdgeColor', [0 0 0], ...
                            'LineWidth', 0.5, ...
                            'HitTest', 'off', ...
                            'PickableParts', 'none');
    locPlots.sel = scatter3(ax, NaN, NaN, NaN, ...
                            220, 'y', 'filled', ...
                            'MarkerEdgeColor', 'k', ...
                            'LineWidth', 1.5, ...
                            'Visible', 'off', ...
                            'HitTest', 'off', ...
                            'PickableParts', 'none');
end

function paramOptions = createParamOptions(data_struct)
    paramOptions = struct('label', {}, 'field', {}, 'units', {});
    nPoints = size(data_struct.branchList, 1);
    preferred = {
        'area_val',            'Cross-sectional Area', 'cm^2';
        'diam_val',            'Area Ratio',           '';
        'flowPerHeartCycle_val','Total Flow',          'mL/s';
        'maxVel_val',          'Maximum Velocity',     'cm/s';
        'velMean_val',         'Mean Velocity',        'cm/s';
        'StdvFromMean',        'Flow Consistency',     '';
        'RI_val',              'Resistance Index',     '';
        'PI_val',              'Pulsatility Index',    ''
    };

    added = {};
    for i = 1:size(preferred,1)
        field = preferred{i,1};
        if isfield(data_struct, field) && numel(data_struct.(field)) == nPoints
            paramOptions(end+1) = struct( ...
                'label', preferred{i,2}, ...
                'field', field, ...
                'units', preferred{i,3}); %#ok<AGROW>
            added{end+1} = field; %#ok<AGROW>
        end
    end

    dataFields = fieldnames(data_struct);
    for i = 1:numel(dataFields)
        field = dataFields{i};
        if ismember(field, added)
            continue;
        end
        vals = data_struct.(field);
        if isnumeric(vals) && isvector(vals) && numel(vals) == nPoints
            label = strrep(field, '_', ' ');
            label = regexprep(label, '(\<[a-z])', '${upper($1)}');
            paramOptions(end+1) = struct( ...
                'label', label, ...
                'field', field, ...
                'units', '');
            added{end+1} = field; %#ok<AGROW>
        end
    end

    if isempty(paramOptions)
        paramOptions = struct('label', 'Total Flow', ...
                              'field', 'flowPerHeartCycle_val', ...
                              'units', 'mL/s');
    end
end

function setupCrossAxes(ax, titleText)
    imagesc(ax, zeros(10)); %#ok<MCSUP>
    axis(ax, 'image');
    axis(ax, 'off');
    colormap(ax, gray);
    title(ax, titleText, 'Color', 'w', 'FontSize', 10);
end

function prepareWaveformAxes(ax)
    hold(ax, 'on');
    ax.XColor = [1 1 1];
    ax.YColor = [1 1 1];
    ax.Color = [0.1 0.1 0.1];
end

function applyParameterSelection(fig, idx, resetLimits)
    appData = guidata(fig);
    option = appData.paramOptions(idx);
    data = double(appData.data_struct.(option.field));
    appData.currentParamIndex = idx;
    appData.paramData = data;
    appData.paramLabel = option.label;
    appData.paramUnits = option.units;
    guidata(fig, appData);

    scatterAll = appData.scatterAll;
    scatterAll.CData = data;

    if strcmpi(appData.paramUnits, '')
        appData.colorbar.Label.String = option.label;
    else
        appData.colorbar.Label.String = sprintf('%s (%s)', option.label, appData.paramUnits);
    end

    finiteVals = data(isfinite(data));
    if isempty(finiteVals)
        finiteVals = [0 1];
    end
    minVal = min(finiteVals);
    maxVal = max(finiteVals);
    if resetLimits || any(~isfinite(caxis(appData.axes)))
        caxis(appData.axes, [minVal maxVal]);
    end
    limits = caxis(appData.axes);
    appData.cbMinEdit.String = sprintf('%.3f', limits(1));
    appData.cbMaxEdit.String = sprintf('%.3f', limits(2));

    if ~isempty(appData.selection.selIndices)
        appData.scatterSel.CData = data(appData.selection.selIndices);
    end

    guidata(fig, appData);
end

function updateSelection(fig, selectionIdx, vesselNames, locKeys)
    appData = guidata(fig);
    scatterAll = appData.scatterAll;
    scatterSel = appData.scatterSel;
    locPlots = appData.locPlots;
    branchList = appData.branchList;
    correspondenceDict = appData.correspondenceDict;
    locInfo = appData.locInfo;

    scatterSel.Visible = 'off';
    locPlots.sel.Visible = 'off';
    appData.selection.key = '';
    appData.selection.locIndex = [];
    appData.selection.selIndices = [];
    appData.selection.pointRow = [];
    appData.cursorMarker.Visible = 'off';
    updateInfoBox(fig, [], []);

    scatterAll.MarkerFaceAlpha = 0.8;
    scatterAll.MarkerEdgeAlpha = 0.8;
    scatterAll.CData = appData.paramData;

    if selectionIdx <= 1 || isempty(vesselNames)
        scatterAll.Visible = 'on';
        guidata(fig, appData);
        return;
    end

    key = locKeys{selectionIdx-1};
    appData.selection.key = key;

    segments = [];
    if isfield(correspondenceDict, key)
        segments = unique(correspondenceDict.(key));
    elseif strcmpi(key, 'COMM') && isfield(correspondenceDict, 'COMM')
        segments = unique(correspondenceDict.COMM);
    end

    segMask = ismember(branchList(:,4), segments);
    if ~any(segMask)
        warning('paramMap_GUI:EmptySegment', ...
                'No centerline points found for vessel %s.', key);
        guidata(fig, appData);
        return;
    end

    scatterAll.MarkerFaceAlpha = 0.05;
    scatterAll.MarkerEdgeAlpha = 0.05;

    scatterSel.Visible = 'on';
    scatterSel.XData = branchList(segMask, 1);
    scatterSel.YData = branchList(segMask, 2);
    scatterSel.ZData = branchList(segMask, 3);
    scatterSel.CData = appData.paramData(segMask);

    appData.selection.selIndices = find(segMask);

    locIdx = find(strcmp({locInfo.key}, key), 1);
    if ~isempty(locIdx)
        appData.selection.locIndex = locIdx;
        locEntry = locInfo(locIdx);
        locPlots.sel.Visible = 'on';
        locPlots.sel.XData = locEntry.coord(1);
        locPlots.sel.YData = locEntry.coord(2);
        locPlots.sel.ZData = locEntry.coord(3);
        updateInfoBox(fig, key, locEntry);
        updateSelectedPoint(fig, locEntry.rowIdx);
    else
        updateInfoBox(fig, key, []);
    end

    guidata(fig, appData);
end

function updateInfoBox(fig, key, locEntry)
    appData = guidata(fig);
    infoBox = appData.infoBox;
    if isempty(key)
        infoBox.String = sprintf('Select a vessel to inspect centerline points and LOCs.\nClick any point in the 3D view to inspect its cross-section.');
        return;
    end

    pretty = buildDisplayNames({key});
    label = pretty{1};

    if isempty(locEntry)
        infoBox.String = sprintf('Vessel: %s\nNo LOC data available.', label);
        return;
    end

    paramVal = appData.paramData(locEntry.rowIdx);
    if isempty(appData.paramUnits)
        paramLine = sprintf('%s: %.3f', appData.paramLabel, paramVal);
    else
        paramLine = sprintf('%s: %.3f %s', appData.paramLabel, paramVal, appData.paramUnits);
    end

    infoBox.String = sprintf(['Vessel: %s\n' ...
                              'Segment ID: %d\n' ...
                              'Centerline Index: %d\n' ...
                              'Mean Flow: %.3f mL/s\n' ...
                              'PI: %.3f\n' ...
                              'RI: %.3f\n' ...
                              '%s'], ...
                              label, locEntry.segment, locEntry.clIndex, ...
                              locEntry.flow, locEntry.PI, locEntry.RI, paramLine);
end

function changeParameter(fig, newIndex)
    applyParameterSelection(fig, newIndex, true);
    appData = guidata(fig);
    if ~isempty(appData.selection.selIndices)
        scatterSel = appData.scatterSel;
        scatterSel.CData = appData.paramData(appData.selection.selIndices);
    end
    if ~isempty(appData.selection.locIndex)
        locEntry = appData.locInfo(appData.selection.locIndex);
        updateInfoBox(fig, appData.selection.key, locEntry);
    end
    if ~isempty(appData.selection.pointRow)
        displayPointInfo(fig, appData.selection.pointRow);
    end
    guidata(fig, appData);
end

function changeColormap(fig, idx)
    appData = guidata(fig);
    cmap = appData.colormapList{idx};
    colormap(appData.axes, cmap);
end

function updateColorLimits(fig, whichLimit, value)
    appData = guidata(fig);
    if ~isfinite(value)
        return;
    end
    limits = caxis(appData.axes);
    switch whichLimit
        case 'min'
            limits(1) = value;
        case 'max'
            limits(2) = value;
    end
    if limits(1) >= limits(2)
        limits(2) = limits(1) + eps;
    end
    caxis(appData.axes, limits);
    appData.cbMinEdit.String = sprintf('%.3f', limits(1));
    appData.cbMaxEdit.String = sprintf('%.3f', limits(2));
    guidata(fig, appData);
end

function focusOnSelectedLOC(fig)
    appData = guidata(fig);
    if isempty(appData.selection.key) || isempty(appData.selection.locIndex)
        return;
    end
    locEntry = appData.locInfo(appData.selection.locIndex);
    target = locEntry.coord;
    margin = 10;
    ax = appData.axes;
    xlim(ax, target(1) + margin * [-1 1]);
    ylim(ax, target(2) + margin * [-1 1]);
    zlim(ax, target(3) + margin * [-1 1]);
    camtarget(ax, target);
    updateSelectedPoint(fig, locEntry.rowIdx);
end

function resetView(fig)
    appData = guidata(fig);
    ax = appData.axes;
    axis(ax, 'auto');
    axis(ax, 'equal');
    try
        camlight(ax, 'headlight');
    catch ME
        warning('paramMap_GUI:CamlightReset','camlight failed during reset: %s', ME.message);
    end
    lighting(ax, 'gouraud');
    applyParameterSelection(fig, appData.currentParamIndex, false);
    guidata(fig, appData);
end

function onScatterClick(fig, src, evt)
    if ~strcmp(get(fig,'SelectionType'),'normal')
        return;
    end
    appData = guidata(fig);
    idx = [];

    if ~isempty(evt)
        if isprop(evt,'DataIndex') && ~isempty(evt.DataIndex) && evt.DataIndex > 0
            if src == appData.scatterSel && ~isempty(appData.selection.selIndices)
                idx = appData.selection.selIndices(evt.DataIndex);
            else
                idx = evt.DataIndex;
            end
        elseif isprop(evt,'IntersectionPoint') && ~isempty(evt.IntersectionPoint)
            idx = nearestBranchIndex(appData, evt.IntersectionPoint);
        end
    end

    if isempty(idx)
        pos = get(appData.axes, 'CurrentPoint');
        idx = nearestBranchIndex(appData, pos(1,1:3));
    end

    if ~isempty(idx) && idx > 0
        updateSelectedPoint(fig, idx);
    end
end

function updateSelectedPoint(fig, rowIdx)
    appData = guidata(fig);
    if rowIdx < 1 || rowIdx > size(appData.branchList,1)
        return;
    end
    coord = appData.branchList(rowIdx, 1:3);
    appData.cursorMarker.Visible = 'on';
    appData.cursorMarker.XData = coord(1);
    appData.cursorMarker.YData = coord(2);
    appData.cursorMarker.ZData = coord(3);
    appData.selection.pointRow = rowIdx;
    guidata(fig, appData);
    displayPointInfo(fig, rowIdx);
    updateCrossSections(fig, rowIdx);
    updateWaveform(fig, rowIdx);
end

function displayPointInfo(fig, rowIdx)
    appData = guidata(fig);
    if isempty(rowIdx)
        return;
    end
    paramVal = appData.paramData(rowIdx);
    if strcmpi(appData.paramUnits, '')
        paramLine = sprintf('%s: %.3f', appData.paramLabel, paramVal);
    else
        paramLine = sprintf('%s: %.3f %s', appData.paramLabel, paramVal, appData.paramUnits);
    end
    segID = appData.branchList(rowIdx, 4);
    clIdx = appData.branchList(rowIdx, 5);
    flowVal = appData.flowPerHeartCycle_val(rowIdx);
    piVal = appData.PI_val(rowIdx);
    riVal = appData.RI_val(rowIdx);
    infoBox = appData.infoBox;
    infoBox.String = sprintf(['Selected Point\n' ...
                              'Segment ID: %d\n' ...
                              'Centerline Index: %d\n' ...
                              'Flow: %.3f mL/s\n' ...
                              'PI: %.3f\n' ...
                              'RI: %.3f\n' ...
                              '%s'], ...
                              segID, clIdx, flowVal, piVal, riVal, paramLine);
end

function updateCrossSections(fig, rowIdx)
    appData = guidata(fig);
    imdim = appData.imdim;
    mask = reshape(appData.segmentFull(rowIdx,:), imdim, imdim);
    mag = reshape(appData.MAGcrossection(rowIdx,:), imdim, imdim);
    cd = reshape(appData.timeMIPcrossection(rowIdx,:), imdim, imdim);
    velTA = reshape(appData.vTimeFrameave(rowIdx,:), imdim, imdim);

    v1 = squeeze(appData.VplanesAllx(rowIdx,:,:));
    v2 = squeeze(appData.VplanesAlly(rowIdx,:,:));
    v3 = squeeze(appData.VplanesAllz(rowIdx,:,:));
    VcrossTR = 0.1*(v1 + v2 + v3);
    normDim = sqrt(size(VcrossTR,1));
    VcrossTR = reshape(VcrossTR, normDim, normDim, appData.nframes);
    VcrossTR = imresize(VcrossTR(:,:,peakFrameIndex(appData.flowPulsatile(rowIdx,:))), [imdim imdim], 'nearest');

    showCrossSection(appData.axesMAG, mag, mask, 'gray');
    showCrossSection(appData.axesCD, cd, mask, 'gray');
    showCrossSection(appData.axesVelTA, velTA, mask, 'gray');
    showCrossSection(appData.axesVelTR, VcrossTR, mask, 'gray');
end

function idx = peakFrameIndex(flowWaveform)
    [~, idx] = max(abs(flowWaveform));
end

function showCrossSection(ax, imageData, mask, cmapName)
    axes(ax); %#ok<LAXES>
    cla(ax);
    imagesc(ax, imageData);
    axis(ax, 'image');
    axis(ax, 'off');
    colormap(ax, cmapName);
    hold(ax, 'on');
    contour(ax, mask, [0.5 0.5], 'LineWidth', 0.8, 'LineColor', 'w');
    hold(ax, 'off');
    titleText = ax.Title.String;
    if isempty(titleText)
        titleText = '';
    end
    title(ax, titleText, 'Color', 'w', 'FontSize', 10);
end

function updateWaveform(fig, rowIdx)
    appData = guidata(fig);
    ax = appData.axesWave;
    cla(ax);
    prepareWaveformAxes(ax);
    frames = 0:(appData.nframes-1);
    branchId = appData.branchList(rowIdx,4);
    branchMask = appData.branchList(:,4) == branchId;
    branchIndices = find(branchMask);
    [~, order] = sort(appData.branchList(branchMask,5));
    sortedIdx = branchIndices(order);
    pos = find(sortedIdx == rowIdx);
    neighborRange = max(pos-2,1):min(pos+2, numel(sortedIdx));
    neighborIdxs = sortedIdx(neighborRange);

    colorsPrev = {[0.85 0.3 0.3], [0.6 0 0]};
    colorsNext = {[0.2 0.85 0.2], [0 0.5 0]};
    baseline = [];
    for i = 1:numel(neighborIdxs)
        w = appData.flowPulsatile(neighborIdxs(i),:);
        neighborPos = find(sortedIdx == neighborIdxs(i), 1, 'first');
        offset = neighborPos - pos;
        if neighborIdxs(i) == rowIdx
            baseline = w;
            continue;
        end
        if offset < 0
            clr = colorsPrev{min(abs(offset), numel(colorsPrev))};
        else
            clr = colorsNext{min(offset, numel(colorsNext))};
        end
        plot(ax, frames, w, 'Color', clr, 'LineWidth', 1.1, 'LineStyle', '--');
    end
    if isempty(baseline)
        baseline = appData.flowPulsatile(rowIdx,:);
    end
    plot(ax, frames, baseline, 'Color', [0.1 0.7 1], 'LineWidth', 2.2);
    grid(ax, 'on');
    ax.GridColor = [0.5 0.5 0.5];
    ax.GridAlpha = 0.3;
    xlim(ax, [0 appData.nframes-1]);
    xticks(ax, frames);
    xlabel(ax, 'Cardiac Frame', 'Color', 'w');
    ylabel(ax, 'Flow (mL/s)', 'Color', 'w');
    title(ax, 'Time-Resolved Flow', 'Color', 'w');
end

function updateIsosurfaceAlpha(fig, alphaValue)
    appData = guidata(fig);
    if ~isfield(appData, 'surfacePatches')
        return;
    end
    patchNames = fieldnames(appData.surfacePatches);
    for i = 1:numel(patchNames)
        try
            patchHandle = appData.surfacePatches.(patchNames{i});
            if ishandle(patchHandle) || (isobject(patchHandle) && isvalid(patchHandle))
                patchHandle.FaceAlpha = alphaValue;
            end
        catch
            % Skip invalid handles
        end
    end
end

function idx = nearestBranchIndex(appData, pos)
    coords = appData.branchList(:,1:3);
    dists = sum((coords - pos).^2, 2);
    [minDist, idx] = min(dists);
    if ~isfinite(minDist)
        idx = [];
    end
end


